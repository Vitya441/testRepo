package map;

import java.util.HashMap;
import java.util.Map;

public class HashMapEx {
// Ключ - значение
// Состоит из массива структур LinkedList или бакетов(Node)
// Внутри бакетов(ключ_мапы-значение_мапы-хэш_код-указатель на следующий элемент)
// loadFactor - коэфициент(золотая середина = 0.75 между скоростью поиска и памятью)
// capacity(16) * loadFactor(0.75) = 12 - после 12 массив увелииться вдвое
// Коллизия - когда хэш-коды разных объектов совпали, записываем в LinkedList
	
// Если st1 и st5 равны, => равны их хэш-коды, st1 уже записан в Map,
// сначала проверка по hashCdoe потом по equals, если по equals ключи равны, то
// происходит перезапись элемента, если не равны, то записываем st5 за st1 (связный список).

// Get происходит так же, st6 = st3, ищем хэш-код st6 = 562, index = 7, смотрим 7-ой бакет,
// Проверяем по хэш-коду, сравниваем st6 и то что в бакете, если хэш-коды != идем на след. элемент,
// У тебя хэш-код 562? -ДА, -Давай сраниваться по equals,  st3 == st6? -ДА, возвращаем значение этого бакета(Node).
	
	
// Иллюстрация: ~/Документы/Java Collections/HashMap


	public static void main(String[] args) {
		Map<Integer, String> map2 = new HashMap<>(16, 0.75f); // дэфолт значения capacity и  loadFactor
		// loadFactor = 0.75, capacity = 16.
		// 16 * 0.75 = 12, после 12 элементов массив увеличиться вдвое и произойдет РеХэширование всех эл-тов
		// Чем больше начальный capacity, тем больше памяти тратиться, но выигрываем во времени,
		// меньше линкед-листов будет, если экономим память, то теряем во времени, больше будет LinkedListoв
		// Прохождение по LinkedList = O(n) - плохо
		// Скорость поиска или вставки в HashMap = O(1) - в лучшем случаем, если эл-ты нормально распределены
		// C версии java 8, после достижения определенного порога, используются сбалансированные деревья, 
		// вместо LinkedList
		
		
	}

}
